- 다형성. 한 개의 객체가 최소 2개 이상 타입
부모 타입으로 부터 파생된 여러 가지 타입을 하나의 타입인 것 처럼
Shape s = new Circle() <-- upcasing
((Circle).s).circleMethod() <-- down casting 형변환 명시
실제는 Shape 타입이기 때문에 s로 circle 메소드 호출 불가

instanceof 연산자를 사용하여 비교할 땐 if else if로
위에는 자식 타입부터 나열해야함.

타입 역할..
상속은 같은 메시지를 수신 가능. 

- 동적바인딩 성립 요건
상속 관계로 이루어져 다형성이 적용된 경우에, 메소드 오버라이딩이 되어 있으면
정적으로 바인딩 된 메소드 코드보다 오버라이딩 된 메소드 코드를 우선적으로 실행

- 추상클래스
abstract 멤버가 0개여도 추상클래스 만들 수 있음
하지만 1개 이상 abstract 메소드가 있다면 반드시 추상클래스.
abstract 메소드는 상속 받으면 반드시 구현해야 한다.(오버라이딩 강제화)
하지만 Product -> SmartPhone -> Galaxy라고 하면
Galaxy에서는 추상메소드를 완성시킬 필요 없음
SmartPhone을 어댑터라고 한다.

생성자는 작성할 수 있고 일반 메소드도 작성할 수 있음.

모든 인터페이스의 메소드는 묵시적으로 public 이고 abstract이다.
인터페이스의 void move() 메소드 오버라이딩 시 public void move() 없이
public 키워드 생략하면 오류 발생.
인터페이스 = implements 키워드
인터페이스 간의 상속은 extends이며 다중 상속을 지원한다.

변수는 묵시적으로 public static final이다
   따라서 인터페이스 값 변경 시도는 컴파일 시 에러를 발생
객체 생성 불가, 참조형 타입으로서는 가능

상위 타입의 역할로 다형성을 지원하여 연결해주는 역할
해당 객체가 다양한 기능을 제공시에도 인터페이스에 해당하는 기능만을 사용하게
제한할 수 있다.
공통 기능상의 일관성 제공 / 공동 작업을 위한 인터페이스 제공

객체를 직접적으로 생성하게 되면 결합관계 형성.. 영향을 끼침
ClassA에서 ClassB객체 생성 시 B객체 이름 수정한다면 A에서도 문제가 생김(결합도)

인터페이스를 두면 간접관계가 되어서 결합도(Coupling)해소 -> 유지보수성 증가
인터페이스 InterB를 만들어서  ClassB에서 implements 해놓으면 interB에 있는
methodB를 classB가 구현하게 되고 A에서 호출할 때 매개변수를 인터페이스 b를 넣으면
클래스 이름만 수정하면 됨 
-> 인터페이스를 필드로 두고 생성자에서 초기화