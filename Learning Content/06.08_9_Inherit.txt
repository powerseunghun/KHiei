상속 (Inherit)
새 클래스가 다른 클래스가 가지고 있는 멤버를 자신의 멤버처럼 사용할 수 있게 만든 기술

상속의 목적
클래스의 재사용, 연관된 일련의 클래스들에 대해 공통적인 규약 정의

장점
- 보다 적은 양의 코드로 새로운 클래스 작성
- 코드를 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
- 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 기여

상속 받는 클래스 : 후손클래스, 자식클래스, 파생클래스, 서브(sub)클래스
상속하는 클래스 : 상위클래스, 부모클래스, 선조클래스, 슈퍼클래스

자식 클래스를 특수화되었다고도 함, 그래서 상속을 일반화 특수화 관계라고 하기도 함
UML의 일반화 보면 화살표 쪽이 부모클래스, 선 끝 쪽이 자식클래스
Association(연관) 관계는 has a 관계를 말함.

상속의 특징.
1. 부모클래스의 생성자, 초기화블럭은 상속 안됨
   - 후손클래스 객체 생성시, 부모클래스 생성자가 먼저 실행
   - super();로 부모클래스 생성자 호출 명시 가능(생략 되어 있음)
     JVM이 자동으로 생성

2. 부모의 private 멤버는 상속은 되지만 접근 불가능
   - 후손 객체 생성시에 부모의 필드값도 전달받은 경우 
   - 전달 받은 부모 필드값을 부모생성자 쪽으로 넘기는 방법 이용

3. 모든 클래스는 Object 클래스의 후손 java.lang.Object
   - Object클래스가 제공하는 메소드를 오버라이딩해서 메소드 본래 기능을 변경 가능
   - to_String, equals, hashcode 대표적인 3가지

Member m = new Member() 하면
스택에 m주소와 super주소... 힙에 실제 객체

오버라이딩의 성립 조건
- 이름이 동일해야 한다.
- 매개변수의 개수, 타입, 순서가 같아야한다
- 리턴 타입이 같아야 한다
- private 메소드의 오버라이딩은 불가능

제어자 조합 유의사항
- 메소드에 static과 abstract 함께 사용 안댐
   static은 프로그램 시작 시 올라가고 abstract는 아직 구현 안 돼 있음
- 클래스에 abstract와 final을 동시에 사용할 수 없다.
   abstract는 무조건 구현해야 하는데 final은 변경할 수 없단 뜻
- abstract 메소드의 접근제어자가 private일 수 없다.
   무조건 접근해서 구현해야함
- 메소드에 private와 final을 같이 사용할 수 없다.
   마찬가지로 무조건 구현..

클래스와 메소드의 final키워드
4군데에 붙는다.. 의미

getInformation에서 super.getInformation() 하지 않고 
this.getInformation()을 하게 되면 재귀호출이 발생 스택 오버플로우 
this. super. 키워드 생략하면 default는 this.

매개변수 있는 생성자가 하나라도 있으면
JVM이 기본 생성자 만들어주지 않으므로
상속 해주는 클래스가 기본 생성자가 명시적으로 없으면
상속 받는 클래스에서는 super(); 구문에서 에러 발생

attach source 
external source -> java\jdk_version\src.zip

hashcode() 오버라이딩
주소 값이 같으면 동일 객체, 주소 값은 틀리지만 같은 값이면 동등객체.
HashMap에서는 키값이 유일해야 함.
만약 동등객체가 하나는 key값이 1,2,3,4
다른 하나는 key 값이 5,6,7,8 이라면
동등객체는 두 값을 같게 반환할 수 있도록




































