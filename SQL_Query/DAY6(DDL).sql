-- DAY 6 수업내용

-- DDL(DATA DEFINITION LANGUAGE) : 데이터 정의 언어
-- 객체(OBJECT)를 만들고(CREATE), 수정(ALTER)하고, 삭제(DROP) 하는 구문

-- 오라클 객체
-- : 테이블(TABLE), 뷰(VIEW), 시퀀스(SEQUENCE),
--   인덱스(INDEX), 패키지(PACKAGE), 트리거(TRIGGER),
--   동의어(SYNONYM), 프로시져(PROCEDURE), 함수(FUNCTION), 사용자(USER)

-- 테이블 만들기
-- [표현식] :
-- CREATE TABLE 테이블명(컬럼명 자료형(크기), 컬럼명 자료형(크기), ...);

CREATE TABLE MEMBER(
  MEMBER_ID VARCHAR2(20),
  MEMBER_PWD VARCHAR2(20),
  MEMBER_NAME VARCHAR2(20)
);

-- 컬럼에 주석 달기
-- [표현식]
-- COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME Is '회원이름';

SELECT *FROM MEMBER;
INSERT INTO MEMBER VALUES('seunghun457', '1234', '파워승훈');
DELETE FROM MEMBER WHERE MEMBER_ID='seunghun457';
COMMIT;

SELECT *FROM TAB;

-- 데이터 딕셔너리 뷰

-- 유저가 가지고 있는 테이블
SELECT *FROM USER_TABLES;

-- 유저가 가지고 있는 테이블 컬럼까지 보여줌
-- WHERE 절에서 설정해서 원하는 테이블만 볼 수 있음.
SELECT *FROM USER_TAB_COLUMNS
WHERE TABLE_NAME = 'MEMBER';

-- 제약조건
-- 테이블 작성 시 각 컬럼에 대해 값 기록에 대한 제약조건을 설정할 수 있다.
-- 데이터 무결성 보장을 목적으로 한다.
-- 입력/수정하는 데이터에 문제가 없는지 자동으로 검사하는 목적
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY

SELECT * FROM USER_CONSTRAINTS;

SELECT *FROM USER_CONS_COLUMNS;

-- NOT NULL : 해당 컬럼에 반드시 값이 기록되어야 하는 경우 사용
--            삽입/수정 시 NULL 값을 허용하지 않도록 컬럼레벨에서 제한
CREATE TABLE USER_NOCONS (
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOCONS 
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_NOCONS
VALUES(2, NULL, NULL, NULL, NULL, '010-1234-5678', 'hong123@kh.or.kr');

SELECT *FROM USER_NOCONS;

CREATE TABLE USER_NOTNULL (
  USER_NO NUMBER NOT NULL,      -- 컬럼 레벨 제약조건 설정
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30) NOT NULL,
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT INTO USER_NOTNULL
VALUES(1, 'user01', 'pass01', NULL, NULL, '010-1234-5678', 'hong123@kh.or.kr');

-- 제약조건 확인
-- sqldeveloper에서는 테이블 더블 클릭 후, 제약조건 탭에서 확인가능
-- NOT NULL은 밑의 테이블에서 CONSTRAINT_TYPE (C = CHECK) (NOT NULL도 일종의 CHECK 제약)
-- 와 SEARCH_CONDITION의 NOT NULL 같이 확인해야함.
SELECT *
FROM USER_CONSTRAINTS C1
JOIN USER_CONS_COLUMNS C2 USING(CONSTRAINT_NAME)
WHERE C1.TABLE_NAME = 'USER_NOTNULL';

-- UNIQUE 제약조건 : 컬럼에 입력값에 대해 중복을 제한하는 제약조건
--                  컬럼 레벨에서 설정 가능, 테이블 레벨에서 설정 가능
SELECT *FROM USER_NOCONS;
INSERT INTo USER_NOCONS
VALUES (1, 'user01', 'pass01', '홍길동' , '남', '010-1234-5678', 'hong123@kh.or.kr');

CREATE TABLE USER_UNIQUE (
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE NOT NULL,   -- 컬럼 레벨에서 제약조건 설정
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR(50)
);

INSERT INTO USER_UNIQUE
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_UNIQUE
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

-- SYS_C007051
SELECT *
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME)
WHERE CONSTRAINT_NAME = 'SYS_C007051';

SELECT
       UCC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UCC.CONSTRAINT_NAME = 'SYS_C007051';

CREATE TABLE USER_UNIQUE2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_ID)        -- 테이블 레벨에서 제약조건 설정, 결과 같으나 위치 차이
);

INSERT INTO USER_UNIQUE2
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_UNIQUE2
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

SELECT *FROm USER_UNIQUE2;

SELECT *
  FROM USER_CONSTRAINTS
  JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME)
where USER_CONSTRAINTS.TABLE_NAME = 'USER_UNIQUE2';

-- 두 개 컬럼을 묶어서 하나의 UNIQUE 제약조건 설정 (테이블 레벨에서만 가능)
CREATE TABLE USER_UNIQUE3(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_NO, USER_ID)
);

INSERT INTO USER_UNIQUE3
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES (2, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES (1, 'user02', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_UNIQUE3
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

SELECT 
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UCC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UCC.CONSTRAINT_NAME = 'SYS_C007054';

-- 제약조건 이름 설정
CREATE TABLE CONS_NAME(
  TEST_DATA1 VARCHAR2(20) CONSTRAINT NN_TEST_DATA1 NOT NULL,
  TEST_DATA2 VARCHAR2(20) CONSTRAINT UK_TEST_DATA2 UNIQUE,
  TEST_DATA3 VARCHAR2(30),
  CONSTRAINT UK_TEST_DATA3 UNIQUE(TEST_DATA3)
);

SELECT *FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'CONS_NAME';

-- CHECK 제약조건 : 컬럼에 기록되는 값에 조건을 설정할 수 있음
-- CHECK (컬럼명 비교연산자 비교값)
-- 주의 : 비교값은 리터럴만 사용할 수 있고, 변하는 값이나 함수 사용하지 못함 형변환은 가능(TO_DATE 등)
-- 컬럼 레벨과 테이블 레벨에서 둘 다 설정 가능함
CREATE TABLE USER_CHECK(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10) CHECK (GENDER IN ('남', '여')),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT INTO USER_CHECK
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_CHECK
VALUES (1, 'user02', 'pass02', '홍길동', '남자', '010-1234-5678', 'hong123@kh.or.kr');

SELECT 
       *
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'SYS_C007059';
 
CREATE TABLE TEST_CHECK(
  TEST_NUMBER NUMBER,
  CONSTRAINT CK_TEST_NUMBER CHECK (TEST_NUMBER > 0)
);

INSERT INTO TEST_CHECK 
VALUES(-5);
INSERT INTO TEST_CHECK 
VALUES(-10);

CREATE TABLE TBL_CHECK (
  C_NAME VARCHAR2(10),
  C_PRICE NUMBER,
  C_LEVEL CHAR(1),
  C_DATE DATE,
  CONSTRAINT CK_C_PRICE CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
  CONSTRAINT CK_C_LEVEL CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
  CONSTRAINT CK_C_DATE CHECK(C_DATE >= TO_DATE('2016/01/01', 'YYYY/MM/DD'))
);

-- 회원가입용 테이블 생성(USER_TEST)
-- 컬럼명 : USER_NO(회원번호)
--         USER_ID(회원아이디)     중복 금지, NULL값 허용 안함
--         USER_PWD(회원비밀번호)   NULL값 허용 안함
--         PNO(주민등록번호)       중복 금지, NULL값 허용 안함
--         GENDER(성별)           '남' 혹은 '여'로 입력
--         PHONE(연락처)
--         ADDRESS(주소)
--         STATUS(탈퇴여부)        NULL값 허용 안함, 'Y' 혹은 'N'으로 입력
-- 각 컬럼에 제약조건 부여할 때 제약조건 이름 부여할 것
-- 테이블 생성 후 5명 이상의 회원 정보 INSERT
-- 각 컬럼별로 괄호안에 있는 내용으로 코멘트 생성

CREATE TABLE USER_TEST(
  USER_NO NUMBER,
  USER_ID VARCHAR2(10) CONSTRAINT NN_USER_ID NOT NULL 
                       CONSTRAINT UN_USER_ID UNIQUE,
  USER_PWD VARCHAR2(20) CONSTRAINT NN_USER_PWD NOT NULL,
  PNO VARCHAR2(20) CONSTRAINT NN_PNO NOT NULL 
                   CONSTRAINT UN_PNO UNIQUE,
  GENDER VARCHAR2(5) CONSTRAINT CK_GENDER CHECK(GENDER IN ('남', '여')),
  PHONE VARCHAR2(20),
  ADDRESS VARCHAR2(50),
  STATUS VARCHAR2(5) CONSTRAINT NN_STATUS NOT NULL 
                     CONSTRAINT CK_STATUS CHECK (STATUS IN ('Y', 'N'))
);
SELECT
       *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'USER_TEST';

SELECT
       *
  FROM USER_CONSTRAINTS
 WHERE TABLE_NAME = 'USER_TEST';

COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민등록번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '연락처';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';

INSERT INTO USER_TEST 
VALUES(1, 'user01', 'pass01', '000000-1111111', '남', '010-1234-5678'
        , '경기도 시흥시 하중동', 'N');
        
INSERT INTO USER_TEST 
VALUES(2, 'user02', 'pass02', '000000-1111112', '여', '010-1456-5678'
        , '경기도 시흥시 대야동', 'N');

INSERT INTO USER_TEST 
VALUES(3, 'user03', 'pass03', '000000-1111113', '남', '010-1885-5678'
        , '경기도 시흥시 매화동', 'N');

INSERT INTO USER_TEST 
VALUES(4, 'user04', 'pass04', '000000-1111114', '여', '010-5959-5678'
        , '경기도 시흥시 미산동', 'N');

INSERT INTO USER_TEST 
VALUES(5, 'user05', 'pass05', '000000-1111115', '남', '010-7456-5678'
        , '경기도 시흥시 은행동', 'Y');
        
SELECT *FROM USER_TEST;

-- PRIMARY KEY(기본키) 제약조건
-- : 테이블에서 한 행의 정보를 찾기 위해 사용할 컬럼을 의미한다.
--   테이블에 대한 식별자 역할을 한다.
--   NOT NULL + UNIQUE 제약조건
--   한 테이블 당 한 개만 설정할 수 있음
--   컬럼 레벨, 테이블 레벨 둘 다 설정 가능
--   한 개 컬럼에 설정할 수 도 있고, 여러 개 컬럼을 묶어서 설정할 수 있음

CREATE TABLE USER_PRIMARYKEY (
  USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY,   -- 컬럼 레벨
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50)
);

INSERT INTO USER_PRIMARYKEY
VALUES(1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

-- PRIMARY 제약조건이지만 UNIQUE 제약조건 위배
INSERT INTO USER_PRIMARYKEY
VALUES(1, 'user02', 'pass02', '이순신', '남', '010-5678-9012', 'lee123@kh.or.kr');

-- Cannot insert NULL into (OWNER.TABLE.COLUMN)
INSERT INTO USER_PRIMARYKEY
VALUES(NULL, 'user03', 'pass03', '유관순', '여', '010-9999-3131', 'yoo123@kh.or.kr');

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAMe = 'PK_USER_NO';
 
CREATE TABLE USER_PRIMARYKEY2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

INSERT INTO USER_PRIMARYKEY2
VALUES (1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2
VALUES (1, 'user02', 'pass02', '이순신', '남', '010-5678-9012', 'lee123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2
VALUES (2, 'user01', 'pass01', '유관순', '여', '010-9999-3131', 'yoo123@kh.or.kr');

INSERT INTO USER_PRIMARYKEY2
VALUES (1, 'user01', 'pass01', '신사임당', '여', '010-9999-9999', 'shin123@kh.or.kr');
SELECT
      UC.TABLE_NAME
    , UCC.COLUMN_NAME
    , UC.CONSTRAINT_NAME
    , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME=UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'PK_USER_NO2';

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.TABLE_NAME = 'USER_PRIMARYKEY2';
 
-- FOREIGN KEY (외부키/외래키) 제약조건
-- : 참조(REFERRENCES)된 다른 테이블에서 제공하는 값만 사용할 수 있음
--   참조 무결성을 위배하지 않게 하기 위해 사용
--   FOREIGEN KEY 제약조건에 의해서
--   테이블간의 관계(RELATIONSHIP)가 형성됨
--   제공되는 값 외에는 NULL을 사용할 수 없음

-- 컬럼 레벨의 경우
-- 컬럼명 자료형(크기) [CONSTRATINTS 이름] REFERRENCES 참조할테이블명 [(참조할컬럼)] [삭제룰]

-- 참조할 테이블의 참조할 컬럼명이 생략되면
-- PRIMARY KEY로 설정한 컬럼이 자동 참조할 컬럼

-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과, UNIQUE 지정된 컬럼만 외래키로 사용할 수 있음

-- 추가적으로, 한 컬럼이 두 개 이상의 테이블을 참조할 수 없음

-- USER_GRADE가 부모 테이블(내가 참조하고 있는 테이블이 부모)
CREATE TABLE USER_GRADE(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE
VALUES (10, '일반회원');

INSERT INTO USER_GRADE
VALUES (20, '우수회원');

INSERT INTO USER_GRADE
VALUES (30, '특별회원');

COMMIT;

SELECT *FROM USER_GRADE;

CREATE TABLE USER_FOREIGNKEY(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE (GRADE_CODE)
);

INSERT INTO USER_FOREIGNKEY
VALUES(1, 'user01', 'pass01', '홍길동', '남',
       '010-1234-5678', 'hong123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY
VALUES(2, 'user02', 'pass02', '이순신', '남',
       '010-5678-9012', 'lee123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY
VALUES(3, 'user03', 'pass03', '유관순', '여',
       '010-9999-3131', 'yoo123@kh.or.kr', 30);
       
INSERT INTO USER_FOREIGNKEY
VALUES(4, 'user04', 'pass04', '안중근', '남',
       '010-2222-0000', 'ahn123@kh.or.kr', null);

-- 참조하려는 값이 없으므로 error       
INSERT INTO USER_FOREIGNKEY
VALUES(5, 'user05', 'pass05', '윤봉길', '남',
       '010-6666-1234', 'yoon123@kh.or.kr', 50);
       
SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.CONSTRAINT_NAME = 'FK_GRADE_CODE';

-- USER_FOREIGNKEY 테이블에서
-- 회원아이디, 이름, 성별, 연락처, 회원등급명 조회
SELECT
       USER_ID
     , USER_NAME
     , GENDER
     , PHONE
     , GRADE_NAME
 FROM USER_FOREIGNKEY
-- LEFT JOIN USER_GRADE USING(GRADE_CODE);
NATURAL LEFT JOIN USER_GRADE;

-- 삭제옵션
-- : 부모 테이블의 데이터 삭제 시 자식 테이블의 데이터를 어떤 식으로 처리할 지에 대한
--   내용을 설정할 수 있다.

-- child record found
DELETE FROM USER_GRADE
WHERE GRADE_CODE = 10;

DELETE FROM USER_GRADE
WHERE GRADE_CODE = 20;

SELECT *FROM USER_GRADE;

ROLLBACK;

-- FOREIGN KEY로 지정된 컬럼에서 사용되고 있는 값일 경우
-- 제공하는 컬럼의 값은 삭제하지 못한다.
-- ON DELETE RESTRICTED (기본값)

-- ON DELETE SET NULL : 부모키를 삭제할 때 자식 키를 NULL로 바꾸어 준다.
CREATE TABLE USER_GRADE2(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE2
VALUES(10, '일반회원');
INSERT INTO USER_GRADE2
VALUES(20, '우수회원');
INSERT INTO USER_GRADE2
VALUES(30, '특별회원');

SELECT *FROM USER_GRADE2;

CREATE TABLE USER_FOREIGNKEY2(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY (GRADE_CODE)
  REFERENCES USER_GRADE2 (GRADE_CODE) ON DELETE SET NULL
);

INSERT INTO USER_FOREIGNKEY2
VALUES (1, 'user01', 'pass01', '홍길동', '남', 
        '010-1234-5678', 'hong123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY2
VALUES (2, 'user02', 'pass02', '이순신', '남', 
        '010-5678-9012', 'lee123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY2
VALUES (3, 'user03', 'pass03', '유관순', '여', 
        '010-9999-3131', 'yoo123@kh.or.kr', 30);
        
INSERT INTO USER_FOREIGNKEY2
VALUES (4, 'user04', 'pass04', '안중근', '남',
        '010-2222-1111', 'ahn123@kh.or.kr', null);

DELETE FROM USER_GRADE2
WHERE GRADE_CODE = 10;
        
SELECT *FROM USER_GRADE2;
SELECT *FROM USER_FOREIGNKEY2;

-- ON DELETE CASCADE : 부모 키 삭제 시 자식 키를 가진 행도 함께 삭제
CREATE TABLE USER_GRADE3(
  GRADE_CODE NUMBER PRIMARY KEY,
  GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT INTO USER_GRADE3
VALUES(10, '일반회원');
INSERT INTO USER_GRADE3
VALUES(20, '우수회원');
INSERT INTO USER_GRADE3
VALUES(30, '특별회원');

SELECT *FROM USER_GRADE3;

CREATE TABLE USER_FOREIGNKEY3(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY (GRADE_CODE)
  REFERENCES USER_GRADE3 (GRADE_CODE) ON DELETE CASCADE
);

INSERT INTO USER_FOREIGNKEY3
VALUES (1, 'user01', 'pass01', '홍길동', '남', 
        '010-1234-5678', 'hong123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY3
VALUES (2, 'user02', 'pass02', '이순신', '남', 
        '010-5678-9012', 'lee123@kh.or.kr', 10);

INSERT INTO USER_FOREIGNKEY3
VALUES (3, 'user03', 'pass03', '유관순', '여', 
        '010-9999-3131', 'yoo123@kh.or.kr', 30);
        
INSERT INTO USER_FOREIGNKEY3
VALUES (4, 'user04', 'pass04', '안중근', '남',
        '010-2222-1111', 'ahn123@kh.or.kr', null);
        
SELECT *FROM USER_FOREIGNKEY3;
COMMIT;

DELETE FROM USER_GRADE3
WHERE GRADE_CODE = 10;

SELECT *FROM USER_GRADE3;
SELECT *FROM USER_FOREIGNKEY3;

-- 서브쿼리를 이용한 테이블 생성
CREATE TABLE EMPLOYEE_COPY
AS SELECT *FROM EMPLOYEE
-- 테이블의 구조만 복사할 때 사용 (1 = 0은 무조건 FALSE)
WHERE 1 = 0;

SELECT *FROM EMPLOYEE_COPY;

DROP TABLE EMPLOYEE_COPY;

-- 컬럼명, 데이터 타입, 값이 복사되고, 제약조건은 NOT NULL만 복사됨
CREATE TABLE EMPLOYEE_COPY2
AS SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE, JOB_NAME
     FROM EMPLOYEE E
     LEFT JOIN DEPARTMENT D ON(E.DEPT_CODE=D.DEPT_ID)
     LEFT JOIN JOb J ON(E.JOB_CODE = J.JOB_CODE);

SELECT *FROM EMPLOYEE_COPY2;

-- 제약조건 추가
-- ALTER TABLE 테이블명 ADD PRIMARY KEY (컬럼명);
-- ALTER TABLE 테이블명 ADD FOREIGN KEY (컬럼명)
--                         REFERENCES 테이블명 (컬럼명);
-- ALTER TABLE 테이블명 ADD UNIQUE (컬럼명)
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명 비교연산자 비교값)
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL;    NULL 허용을 NOT NULL로
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NULL;        NOT NULL을 NULL 허용으로 스위치 식으로 MODIFY

ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY (EMP_ID);
ALTER TABLE EMPLOYEE_COPY MODIFY EMP_NO NOT NULL;

-- 실습
-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조 컬럼의 DEPARTMENT의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (DEPT_CODE)
                         REFERENCES DEPARTMENT(DEPT_ID);
-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
ALTER TABLE DEPARTMENT ADD FOREIGN KEY (LOCATION_ID)
                           REFERENCES LOCATION (LOCAL_CODE);
-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB, 참조 컬럼은 JOB의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE)
                         REFERENCES JOB(JOB_CODE);
-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조 테이블은 SAL_GRADE, 참조 컬럼은 SAL_GRADE 테이블의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL)
                         REFERENCES SAL_GRADE(SAL_LEVEL);
-- EMPLOYEE 테이블의 EMT_YN 컬럼에 CHECK 제약조건 추가 ('Y', 'N')
-- 단, 대 소문자를 구분하기 때문에 대문자로만 설정할 것
ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN ('Y', 'N'));
-- EMPLOYEE 테이블의 SALARY 컬럼에 CHECK 제약조건 추가(양수)
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);
-- EMPLOYEE 테이블의 EMP_NO 컬럼에 UNIQUE 제약조건 추가
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);

-- ALTER TABLE EMPLOYEE DROP CONSTRAINT SYS_C007156;

SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON (UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME)
 WHERE UC.TABLE_NAME = 'EMPLOYEE';
